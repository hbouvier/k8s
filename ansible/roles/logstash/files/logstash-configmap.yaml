---
apiVersion: v1
kind: ConfigMap
metadata:
  name: logstash
  labels:
    app: elk
    component: logstash
    role: aggregator
data:
  logstash.conf: |-
    input {  
      beats {
        port => "5043"
      }
      beats {
        port => "5044"
        codec => json
      }
      http {
        port => 8080
        type  => http_json_endpoint
        codec => json
      }
      tcp {
        port => 5000
        type => syslog
      }
      udp {
        port => 5000
        type => syslog
      }
      # journald {
      #   lowercase => true
      #   seekto => "head"
      #   thisboot => true
      #   type => "systemd"
      #   tags => [ "coreos" ]
      # }
    }

    filter {
      if [source] =~ "containers" {
        mutate {
          rename => { "log" => "message" }
        }
        
        grok {
          match => [
            "source", "^/var/log/containers/(?<pod_name>[^_]+)_(?<namespace>[^_]+)_%{GREEDYDATA:container_name}-(?<container_id>[^\.]+).log"
          ]
        }
        date {
          match => ["time", "ISO8601"]
          remove_field => ["time"]
        }

        mutate {
          add_field => {
            "process_name"      => "%{container_name}"
            "process_source"    => "%{pod_name}"
          }
        }

        mutate {
          rename => [ "container_id",                 "[kubernetes][container_id]" ]
          rename => [ "container_name",               "[kubernetes][container_name]" ]
          rename => [ "namespace",                    "[kubernetes][namespace]" ]
          rename => [ "pod_name",                     "[kubernetes][pod_name]" ]
          rename => [ "process_name",                 "[process][name]" ]
          rename => [ "process_source",               "[process][source]" ]
        }
      }
    }


    # Dec 29 00:27:41 ip-172-20-56-99 kubelet[849]: I1229 00:27:41.685542     849 operation_executor.go:917] MountVolume.SetUp succeeded for volume
    # Dec 29 07:55:15 ip-172-20-56-99 kubelet[849]: W1229 07:55:15.862591     849 container_manager_linux.go:662] CPUAccounting not enabled for pid: 849
    # Dec 29 12:46:08 ip-172-20-56-99 kernel: [62534.247367] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready
    # Dec 28 19:24:31 ip-172-20-56-99 kernel: [    0.150570] ..TIMER: vector=0x30 apic1=0 pin1=2 apic2=0 pin2=0
    filter {
      if !([source] =~ "containers") {
        grok {
          match => [ "message",  "(?<process_timestamp>[a-zA-Z]{3}[ ]+\d+ \d+:\d+:\d+) (?<process_host>[^ ]*) (?<process_name>[^\[: ]*)(\[(?<process_id>\d*)\])?[: ][ ]*%{GREEDYDATA:process_message}" ]
        }
        date {
          match => [ 
            "process_timestamp",
            "MMM dd HH:mm:ss",
            "MMM  d HH:mm:ss",
            "ISO8601"
          ]
        }

        if !("_grokparsefailure" in [tags]) {
          if [process_message] =~ /.+/ {
            mutate {
              replace      => [ "message", "%{process_message}" ]
              remove_field => [ "process_message" ]
              gsub         => [ "message", "#033\[\d+m", "" ]
            }
          }
        }
        if ("_grokparsefailure" in [tags]) {
          grok {
            match => [
              "source", "%{GREEDYDATA}/%{DATA:process_name}(\.log)?$"
            ]
          }        
        }
        
        grok {
          match => [
            "source", "%{GREEDYDATA}/%{DATA:process_source}(\.log)?$"
          ]
        }
        mutate {
          rename => [ "process_id",                   "[process][id]" ]
          rename => [ "process_name",                 "[process][name]" ]
          rename => [ "process_host",                 "[process][host]" ]
          rename => [ "process_source",               "[process][source]" ]
          rename => [ "process_timestamp",            "[process][timestamp]" ]
        }
      }
    }

    filter {
      if [source] =~ "nginx" {
        grok {
          match => [
            "message", "^(?<remote_addr>[^ ]+) - \[(?<proxy_add_x_forwarded_for>[^\]]+)\] - (?<remote_user>[^ ]+) \[(?<time_local>[^\]]+)\] \"(?<request_method>[^ ]+) (?<request_url>[^ ]+) HTTP/(?<http_version>\d+(?:\.\d+)?)\" (?<status>[^ ]+) (?<body_bytes_sent>[^ ]+) \"(?<http_referer>[^\"]+)\" \"(?<http_user_agent>[^\"]+)\" (?<request_length>[^ ]+) (?<request_time>[^ ]+) (?<upstream_addr>[^ ]+) (?<upstream_response_length>[^ ]+) (?<upstream_response_time>[^ ]+) (?<upstream_status>[^ ]+)"
          ]
        }
      }
      if [source] =~ "oauth2-proxy" {
        grok {
          match => [
            "message", "^(?<proxy_add_x_forwarded_for>[^ ]+) (?<unknown_field_one>[^ ]+) (?<remote_user>[^ ]+) \[(?<time_local>[^\]]+)\] (?<http_referer>[^ ]+) (?<request_method>[^ ]+) (?<upstream_addr>[^ ]+) \"(?<request_url>[^\"]+)\" HTTP/(?<http_version>\d+(?:\.\d+)?) \"(?<http_user_agent>[^\"]+)\" (?<status>[^ ]+) (?<upstream_response_length>[^ ]+) (?<upstream_response_time>[^ ]+)"
          ]
        }
      }

      if [source] =~ "nginx" or [source] =~ "oauth2-proxy" {
        if !("_grokparsefailure" in [tags]) {

          if [upstream_response_time] == "-" {
            mutate {
              replace => { "upstream_response_time" => "0" }
            }
          }

          mutate {
            replace => { "message" => "[%{status}] %{remote_user} %{request_method} %{request_url} %{http_referer}" }
            gsub   => [ "message", "\\x22", "\"" ]
          }

          mutate {
            rename => [ "remote_addr",               "[http][remote_addr]" ]
            rename => [ "proxy_add_x_forwarded_for", "[http][proxy_add_x_forwarded_for]" ]
            rename => [ "remote_user",               "[http][remote_user]" ]
            rename => [ "time_local",                "[http][time_local]" ]
            rename => [ "request_method",            "[http][request_method]" ]
            rename => [ "request_url",               "[http][request_url]" ]
            rename => [ "http_version",              "[http][version]" ]
            rename => [ "status",                    "[http][status]" ]
            rename => [ "body_bytes_sent",           "[http][body_bytes_sent]" ]
            rename => [ "http_referer",              "[http][http_referer]" ]
            rename => [ "http_user_agent",           "[http][http_user_agent]" ]
            rename => [ "user_agent",                "[http][user_agent]" ]
            rename => [ "request_length",            "[http][request_length]" ]
            rename => [ "request_time",              "[http][request_time]" ]
            rename => [ "upstream_addr",             "[http][upstream_addr]" ]
            rename => [ "upstream_response_length",  "[http][upstream_response_length]" ]
            rename => [ "upstream_response_time",    "[http][upstream_response_time]" ]
            rename => [ "upstream_status",           "[http][upstream_status]" ]
          }

          geoip {
            source => "[http][remote_addr]"
            target => "geoip"
            database => "/etc/logstash/geoip-database/GeoLite2-City.mmdb"
            add_field => [ "[geoip][coordinates]", "%{[geoip][longitude]}" ]
            add_field => [ "[geoip][coordinates]", "%{[geoip][latitude]}"  ]
          }
          mutate {
            convert => [ "[geoip][coordinates]", "float" ]
          }
        }
      }
    } 

    output {
      elasticsearch { 
        hosts => ["elasticsearch:9200"]
      }
    }
